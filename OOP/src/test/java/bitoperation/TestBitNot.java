package bitoperation;

/**
 * Created by shucheng on 2019-9-29 下午 23:05
 * 按位非操作
 *
 * 代码说明：运行结果为-6
 * 方法1：利用公式 ~n=-n-1，得到~10=-11，所以结果为5+(-11)=-6
 *
 * 方法2：计算机是用补码来进行存储和运算的
 * 10的原码为 00001010，正数的原码、反码和补码相同
 * 对10按位取反，得到 11110101，最高位符号位是1，说明是负数的补码
 *
 * 由于无法直接看出是哪个负数，联想到计算-2的二进制表示时（通常是指补码形式），先知道-2的原码为 10000010，
 * 然后得到-2的反码为 11111101（符号位保持不变，数值位按位取反），再得到补码为 11111110（反码加1）
 *
 * 通过这个过程，我们知道，只要想办法通过负数的补码得到负数的原码就ok了。具体思路就是：对负数的补码先减1，
 * 然后再取反码，这样就得到负数的原码了
 *
 * 以 11110101为例，先减1，得到 11110100，然后再取反码（不管正数还是负数取反码，符号位保持不变，原来是什么就是什么），
 * 得到 10001011，这个就是负数的原码了。这时只要看 1011是多少，然后加个符号就ok了，很明显 1011就是2^3+2^1+2^0=11，
 * 所以这个负数就是-11
 *
 * 参考链接：http://c.biancheng.net/view/290.html（对原码、反码、补码的解释）
 * https://www.cnblogs.com/it-xiaojun/p/4802181.html（计算机为什么要用补码？）
 */
public class TestBitNot {

    public static void main(String[] args) {
        int i = 5;
        int j = 10;
        System.out.println(i + ~j);
    }
}
